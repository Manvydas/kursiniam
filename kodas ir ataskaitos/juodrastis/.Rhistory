par(usr = c(usr[1:2], 0, 1.5) )
h <- hist(x, plot = FALSE)
breaks <- h$breaks; nB <- length(breaks)
y <- h$counts; y <- y/max(y)
rect(breaks[-nB], 0, breaks[-1], y, col = "cyan", ...)
}
panel.cor2 <- function(x, y, digits=2, cex.cor)
{
usr <- par("usr"); on.exit(par(usr))
par(usr = c(0, 1, 0, 1))
r <- abs(cor(x, y))
txt <- format(c(r, 0.123456789), digits=digits)[1]
test <- cor.test(x,y)
Signif <- ifelse(round(test$p.value,3)<0.001,"p<0.001",paste("p=",round(test$p.value,3)))
text(0.5, 0.25, paste("r=",txt))
text(.5, .75, Signif)
}
panel.cor <- function(x, y, digits = 2, prefix = "", cex.cor,...)    #ši funkcija reikalinga grafikų lentelei
#išbrėžti (koreliacijos koeficiento radimui)
{
usr <- par("usr"); on.exit(par(usr))
par(usr = c(0, 1, 0, 1))
r <- abs(cor(x, y))
txt <- format(c(r, 0.123456789), digits = digits)[1]
txt <- paste0(prefix, txt)
if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
text(0.5, 0.5, txt, cex = 3)
}
# Chunk 5
Data = rownames(data3)
Data=as.yearmon(Data, "%YM%m")
data3=cbind.data.frame(Data, data3)
# Chunk 6
Sys.setlocale(locale = "en_LT.UTF-8")
akc = melt(data3[,c("OMX","SP350","SP500","Data")], id=c("Data"))
ggplot(akc) + geom_line(aes(x=Data, y=value, colour=variable)) +
scale_colour_manual(values=c(1:4))+ylab("% pokytis")+
guides(col=guide_legend(title="Kintamieji")) +
ggtitle("Akcijų indeksų mėnesiniai grąžų pokyčiai")
# Chunk 7
pairs(data3[,c("OMX","SP350","SP500")],upper.panel=panel.smooth,diag.panel=panel.hist, lower.panel=panel.cor2)
# Chunk 8
pairs(data3[,c("OMX","infliacija","nedarbas","kursas")],upper.panel=panel.smooth,diag.panel=panel.hist, lower.panel=panel.cor2)
# Chunk 9
pairs(data3[,c("OMX","mhope","phope","vhope","pramhope","vp")],upper.panel=panel.smooth,diag.panel=panel.hist, lower.panel=panel.cor2)
# Chunk 10
ccfvalues <- ccf(data3$OMX,data3$SP350)
ccfvalues
modelis = lm(OMX ~ lag(SP350,1) + lag(kk,1) + lag(dll,1) + nedarbas + lag(infliacija,2) + lag(infliacija,3) + lag(infliacija,5) + lag(infliacija,7) + lag(infliacija,8) +lag(mhope,3) + lag(phope,12) + lag(pramhope,3) + lag(shope,4) + lag(ul,10) + lag(vhope,4) + lag(vp,0) + lag(mp,1) + lag(gkl,9) + lag(ip,0) + lag(ip,1) + lag(ip,4) + lag(kursas,2) , data=data3)
modelis_po_aic <- lm(formula = OMX ~ lag(SP350, 1) + lag(infliacija, 2) + lag(mhope, 3) + lag(phope,12) + lag(ul, 10) + lag(gkl, 9) + lag(ip, 4) + lag(kursas,2), data = data3)
coeftest(modelis_po_aic, vcov=vcovHC)
summary(modelis_po_aic)
# Chunk 11
datafr=data.frame(summary(modelis_po_aic)[c(4,8)] %>%  lapply(round,2))
colnames(datafr)=c("koeficientai","standartinis nuokrypis","koeficientu t reikšmes","p reiksme", "R kvadratas")
datafr[2:nrow(datafr),"R kvadratas"]="-"
kable(datafr)
# Chunk 12
names2=c("SP350","SP500","kk","dll","nedarbas","infliacija","mhope","phope","pramhope","shope","ta","ul","vhope","vp","mp","palukanos","gkl","ip","kursas")
for (i in 3:length(data3[1,])){
ccfvalues <- ccf(data3$OMX,data3[,i]) #aiskinames laga
print(names2[i-2])
print(ccfvalues)
}
# Chunk 13
modelis2 = lm(OMX ~ lag(SP350,0) + lag(kk,1) + lag(dll,1) + lag(nedarbas,5) + lag(mhope,3) + lag(phope,12) + lag(pramhope,3) + lag(shope,1) + lag(ul,10) + lag(vhope,4) + lag(vp,1) + lag(mp,1) + lag(gkl,19) + lag(ip,4) + lag(kursas,2) , data=data3)
modelis_po_aic <- lm(formula = OMX ~ lag(SP350, 1) + lag(nedarbas, 5) + lag(infliacija, 4) +
lag(mhope, 3) + lag(phope, 12) + lag(pramhope, 3) + lag(ul,10) + lag(vhope, 4) + lag(mp, 1) + lag(gkl, 19) + lag(ip,4) + lag(kursas, 2), data = data3)
# Chunk 14
ccfvalues <- ccf(data3$OMX,data3$kursas)
ccfvalues
modelis = lm(OMX ~ lag(SP350,0) + lag(kk,1) + lag(dll,1) + nedarbas + lag(mhope,3) + lag(phope,12) + lag(pramhope,3) + lag(shope,4) + lag(ul,10) + lag(vhope,4) + lag(vp,0) + lag(mp,1) + lag(gkl,9) + lag(ip,0) + lag(ip,1) + lag(ip,4) + lag(kursas,0) + lag(kursas,2) , data=data3)
boo<-stepAIC((modelis))
modelis_po_aic <- lm(formula = OMX ~ lag(SP350, 0) + lag(mhope, 3) + lag(phope, 12) + lag(pramhope, 3) + lag(ul, 10) + lag(gkl, 9) + lag(ip, 1)+ lag(kursas,2) , data = data3)
coeftest(modelis_po_aic, vcov=vcovHC)
summary(modelis_po_aic)
# Chunk 15
res<-bptest(modelis_po_aic)
# Chunk 16
ncvTest(modelis_po_aic)
# Kadangi p-value > 0.05, tai H0 hipotezė priimama - duomenys homoskedastiški.
spreadLevelPlot(modelis_po_aic)
vif(modelis_po_aic)
# Chunk 17
durbinWatsonTest(modelis_po_aic)
# p-value > 0.05 - liekanos nėra autokoreliuotos.
Box.test(modelis_po_aic$res, fitdf=0, type="Lj")
#p-value >0.05, vadinasi H0 neatmetama. Galima teigti, kad liekanos yra baltasis triukšmas.
# Chunk 18
shapiro.test(modelis_po_aic$residuals)
# p-value > 0.05 - liekanos yra normalios
# Chunk 1
library("quantmod")
library("forecast")
library("xts")
library("dplyr")
library("gridExtra")
library("dynlm")
library("ggplot2")
library("reshape2")
library("knitr")
library("tseries")
library("MASS")
library("car")
library("sandwich")
library("lmtest")
# Chunk 2
data=read.csv("rawdata.csv")
data[ data == ":" ] = NA
data=data[complete.cases(data),]
rownames(data)<-NULL
# Chunk 3
data2=apply(data[,-1],2,as.numeric)
rownames(data2)=data[,1]
data2=data.frame(data2)
data2$nedarbas=data2$nedarbas/10
data2[,c("OMX","SP350","SP500","kk","mp","ip")] = apply(data2[,c("OMX","SP350","SP500","kk","mp","ip")],2,log)    #logaritmuojama indeksai, akcijų kainos, kursas
data2[,c("OMX","SP350","SP500","kk","mp","ip")]=data2[,c("OMX","SP350","SP500","kk","mp","ip")]*100
data2$euribor=((data2$euribor+1)^(1/12)-1)*12                    #reiketu gal menesio?
names(data2)[names(data2) == 'euribor'] <- 'palukanos'
data3=data.frame(diff(as.matrix(data2)))
data3$euribor=data2$euribor[-1]
names(data3)[names(data3) == 'euribor'] <- 'palukanos'
data3$gkl = data$gkl[-1]    #gamintoju kainu lygio nereik diferencijuot nes jau yra pokytis %
#tsdisplay(data3$infliacija)
p=apply(data3[,],2,function(i)adf.test(i,k=1)$p.value)
p=data.frame(p)
p[,1] = round(p[,1], digits = 2)
kable(p)
data3$OMX=data3$OMX-data3$palukanos
data3$SP350=data3$SP350-data3$palukanos
data3$SP500=data3$SP500-data3$palukanos
# Chunk 4
panel.hist <- function(x, ...)    #ši funkcija reikalinga grafikų lentelei išbrėžti (histogramos pateikimui)
{
usr <- par("usr"); on.exit(par(usr))
par(usr = c(usr[1:2], 0, 1.5) )
h <- hist(x, plot = FALSE)
breaks <- h$breaks; nB <- length(breaks)
y <- h$counts; y <- y/max(y)
rect(breaks[-nB], 0, breaks[-1], y, col = "cyan", ...)
}
panel.cor2 <- function(x, y, digits=2, cex.cor)
{
usr <- par("usr"); on.exit(par(usr))
par(usr = c(0, 1, 0, 1))
r <- abs(cor(x, y))
txt <- format(c(r, 0.123456789), digits=digits)[1]
test <- cor.test(x,y)
Signif <- ifelse(round(test$p.value,3)<0.001,"p<0.001",paste("p=",round(test$p.value,3)))
text(0.5, 0.25, paste("r=",txt))
text(.5, .75, Signif)
}
panel.cor <- function(x, y, digits = 2, prefix = "", cex.cor,...)    #ši funkcija reikalinga grafikų lentelei
#išbrėžti (koreliacijos koeficiento radimui)
{
usr <- par("usr"); on.exit(par(usr))
par(usr = c(0, 1, 0, 1))
r <- abs(cor(x, y))
txt <- format(c(r, 0.123456789), digits = digits)[1]
txt <- paste0(prefix, txt)
if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
text(0.5, 0.5, txt, cex = 3)
}
# Chunk 5
Data = rownames(data3)
Data=as.yearmon(Data, "%YM%m")
data3=cbind.data.frame(Data, data3)
# Chunk 6
Sys.setlocale(locale = "en_LT.UTF-8")
akc = melt(data3[,c("OMX","SP350","SP500","Data")], id=c("Data"))
ggplot(akc) + geom_line(aes(x=Data, y=value, colour=variable)) +
scale_colour_manual(values=c(1:4))+ylab("% pokytis")+
guides(col=guide_legend(title="Kintamieji")) +
ggtitle("Akcijų indeksų mėnesiniai grąžų pokyčiai")
# Chunk 7
pairs(data3[,c("OMX","SP350","SP500")],upper.panel=panel.smooth,diag.panel=panel.hist, lower.panel=panel.cor2)
# Chunk 8
pairs(data3[,c("OMX","infliacija","nedarbas","kursas")],upper.panel=panel.smooth,diag.panel=panel.hist, lower.panel=panel.cor2)
# Chunk 9
pairs(data3[,c("OMX","mhope","phope","vhope","pramhope","vp")],upper.panel=panel.smooth,diag.panel=panel.hist, lower.panel=panel.cor2)
# Chunk 10
ccfvalues <- ccf(data3$OMX,data3$SP350)
ccfvalues
modelis = lm(OMX ~ lag(SP350,1) + lag(kk,1) + lag(dll,1) + nedarbas + lag(infliacija,2) + lag(infliacija,3) + lag(infliacija,5) + lag(infliacija,7) + lag(infliacija,8) +lag(mhope,3) + lag(phope,12) + lag(pramhope,3) + lag(shope,4) + lag(ul,10) + lag(vhope,4) + lag(vp,0) + lag(mp,1) + lag(gkl,9) + lag(ip,0) + lag(ip,1) + lag(ip,4) + lag(kursas,2) , data=data3)
modelis_po_aic <- lm(formula = OMX ~ lag(SP350, 1) + lag(infliacija, 2) + lag(mhope, 3) + lag(phope,12) + lag(ul, 10) + lag(gkl, 9) + lag(ip, 4) + lag(kursas,2), data = data3)
coeftest(modelis_po_aic, vcov=vcovHC)
summary(modelis_po_aic)
# Chunk 11
datafr=data.frame(summary(modelis_po_aic)[c(4,8)] %>%  lapply(round,2))
colnames(datafr)=c("koeficientai","standartinis nuokrypis","koeficientu t reikšmes","p reiksme", "R kvadratas")
datafr[2:nrow(datafr),"R kvadratas"]="-"
kable(datafr)
# Chunk 12
names2=c("SP350","SP500","kk","dll","nedarbas","infliacija","mhope","phope","pramhope","shope","ta","ul","vhope","vp","mp","palukanos","gkl","ip","kursas")
for (i in 3:length(data3[1,])){
ccfvalues <- ccf(data3$OMX,data3[,i]) #aiskinames laga
print(names2[i-2])
print(ccfvalues)
}
# Chunk 13
modelis2 = lm(OMX ~ lag(SP350,0) + lag(kk,1) + lag(dll,1) + lag(nedarbas,5) + lag(mhope,3) + lag(phope,12) + lag(pramhope,3) + lag(shope,1) + lag(ul,10) + lag(vhope,4) + lag(vp,1) + lag(mp,1) + lag(gkl,19) + lag(ip,4) + lag(kursas,2) , data=data3)
modelis_po_aic <- lm(formula = OMX ~ lag(SP350, 1) + lag(nedarbas, 5) + lag(infliacija, 4) +
lag(mhope, 3) + lag(phope, 12) + lag(pramhope, 3) + lag(ul,10) + lag(vhope, 4) + lag(mp, 1) + lag(gkl, 19) + lag(ip,4) + lag(kursas, 2), data = data3)
# Chunk 14
ccfvalues <- ccf(data3$OMX,data3$kursas)
ccfvalues
modelis = lm(OMX ~ lag(SP350,0) + lag(kk,1) + lag(dll,1) + nedarbas + lag(mhope,3) + lag(phope,12) + lag(pramhope,3) + lag(shope,4) + lag(ul,10) + lag(vhope,4) + lag(vp,0) + lag(mp,1) + lag(gkl,9) + lag(ip,0) + lag(ip,1) + lag(ip,4) + lag(kursas,0) + lag(kursas,2) , data=data3)
boo<-stepAIC((modelis))
modelis_po_aic <- lm(formula = OMX ~ lag(SP350, 0) + lag(mhope, 3) + lag(phope, 12) + lag(pramhope, 3) + lag(ul, 10) + lag(gkl, 9) + lag(ip, 1)+ lag(kursas,2) , data = data3)
coeftest(modelis_po_aic, vcov=vcovHC)
summary(modelis_po_aic)
# Chunk 15
res<-bptest(modelis_po_aic)
# Chunk 16
ncvTest(modelis_po_aic)
# Kadangi p-value > 0.05, tai H0 hipotezė priimama - duomenys homoskedastiški.
spreadLevelPlot(modelis_po_aic)
vif(modelis_po_aic)
# Chunk 17
durbinWatsonTest(modelis_po_aic)
# p-value > 0.05 - liekanos nėra autokoreliuotos.
Box.test(modelis_po_aic$res, fitdf=0, type="Lj")
#p-value >0.05, vadinasi H0 neatmetama. Galima teigti, kad liekanos yra baltasis triukšmas.
# Chunk 18
shapiro.test(modelis_po_aic$residuals)
# p-value > 0.05 - liekanos yra normalios
names2=c("SP350","SP500","kk","dll","nedarbas","infliacija","mhope","phope","pramhope","shope","ta","ul","vhope","vp","mp","palukanos","gkl","ip","kursas")
for (i in 3:length(data3[1,])){
ccfvalues <- ccf(data3$ip,data3[,i]) #aiskinames laga
print(names2[i-2])
print(ccfvalues)
}
]]]]]]]]]
# Chunk 1
library("quantmod")
library("forecast")
library("xts")
library("dplyr")
library("gridExtra")
library("dynlm")
library("ggplot2")
library("reshape2")
library("knitr")
library("tseries")
library("MASS")
library("car")
library("sandwich")
library("lmtest")
# Chunk 2
data=read.csv("rawdata.csv")
data[ data == ":" ] = NA
data=data[complete.cases(data),]
rownames(data)<-NULL
# Chunk 3
data2=apply(data[,-1],2,as.numeric)
rownames(data2)=data[,1]
data2=data.frame(data2)
data2$nedarbas=data2$nedarbas/10
data2[,c("OMX","SP350","SP500","kk","mp","ip")] = apply(data2[,c("OMX","SP350","SP500","kk","mp","ip")],2,log)    #logaritmuojama indeksai, akcijų kainos, kursas
data2[,c("OMX","SP350","SP500","kk","mp","ip")]=data2[,c("OMX","SP350","SP500","kk","mp","ip")]*100
data2$euribor=((data2$euribor+1)^(1/12)-1)*12                    #reiketu gal menesio?
names(data2)[names(data2) == 'euribor'] <- 'palukanos'
data3=data.frame(diff(as.matrix(data2)))
data3$euribor=data2$euribor[-1]
names(data3)[names(data3) == 'euribor'] <- 'palukanos'
data3$gkl = data$gkl[-1]    #gamintoju kainu lygio nereik diferencijuot nes jau yra pokytis %
#tsdisplay(data3$infliacija)
p=apply(data3[,],2,function(i)adf.test(i,k=1)$p.value)
p=data.frame(p)
p[,1] = round(p[,1], digits = 2)
kable(p)
data3$OMX=data3$OMX-data3$palukanos
data3$SP350=data3$SP350-data3$palukanos
data3$SP500=data3$SP500-data3$palukanos
# Chunk 4
panel.hist <- function(x, ...)    #ši funkcija reikalinga grafikų lentelei išbrėžti (histogramos pateikimui)
{
usr <- par("usr"); on.exit(par(usr))
par(usr = c(usr[1:2], 0, 1.5) )
h <- hist(x, plot = FALSE)
breaks <- h$breaks; nB <- length(breaks)
y <- h$counts; y <- y/max(y)
rect(breaks[-nB], 0, breaks[-1], y, col = "cyan", ...)
}
panel.cor2 <- function(x, y, digits=2, cex.cor)
{
usr <- par("usr"); on.exit(par(usr))
par(usr = c(0, 1, 0, 1))
r <- abs(cor(x, y))
txt <- format(c(r, 0.123456789), digits=digits)[1]
test <- cor.test(x,y)
Signif <- ifelse(round(test$p.value,3)<0.001,"p<0.001",paste("p=",round(test$p.value,3)))
text(0.5, 0.25, paste("r=",txt))
text(.5, .75, Signif)
}
panel.cor <- function(x, y, digits = 2, prefix = "", cex.cor,...)    #ši funkcija reikalinga grafikų lentelei
#išbrėžti (koreliacijos koeficiento radimui)
{
usr <- par("usr"); on.exit(par(usr))
par(usr = c(0, 1, 0, 1))
r <- abs(cor(x, y))
txt <- format(c(r, 0.123456789), digits = digits)[1]
txt <- paste0(prefix, txt)
if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
text(0.5, 0.5, txt, cex = 3)
}
# Chunk 5
Data = rownames(data3)
Data=as.yearmon(Data, "%YM%m")
data3=cbind.data.frame(Data, data3)
# Chunk 6
Sys.setlocale(locale = "en_LT.UTF-8")
akc = melt(data3[,c("OMX","SP350","SP500","Data")], id=c("Data"))
ggplot(akc) + geom_line(aes(x=Data, y=value, colour=variable)) +
scale_colour_manual(values=c(1:4))+ylab("% pokytis")+
guides(col=guide_legend(title="Kintamieji")) +
ggtitle("Akcijų indeksų mėnesiniai grąžų pokyčiai")
# Chunk 7
pairs(data3[,c("OMX","SP350","SP500")],upper.panel=panel.smooth,diag.panel=panel.hist, lower.panel=panel.cor2)
# Chunk 8
pairs(data3[,c("OMX","infliacija","nedarbas","kursas")],upper.panel=panel.smooth,diag.panel=panel.hist, lower.panel=panel.cor2)
# Chunk 9
pairs(data3[,c("OMX","mhope","phope","vhope","pramhope","vp")],upper.panel=panel.smooth,diag.panel=panel.hist, lower.panel=panel.cor2)
# Chunk 10
ccfvalues <- ccf(data3$OMX,data3$SP350)
ccfvalues
modelis = lm(OMX ~ lag(SP350,1) + lag(kk,1) + lag(dll,1) + nedarbas + lag(infliacija,2) + lag(infliacija,3) + lag(infliacija,5) + lag(infliacija,7) + lag(infliacija,8) +lag(mhope,3) + lag(phope,12) + lag(pramhope,3) + lag(shope,4) + lag(ul,10) + lag(vhope,4) + lag(vp,0) + lag(mp,1) + lag(gkl,9) + lag(ip,0) + lag(ip,1) + lag(ip,4) + lag(kursas,2) , data=data3)
modelis_po_aic <- lm(formula = OMX ~ lag(SP350, 1) + lag(infliacija, 2) + lag(mhope, 3) + lag(phope,12) + lag(ul, 10) + lag(gkl, 9) + lag(ip, 4) + lag(kursas,2), data = data3)
coeftest(modelis_po_aic, vcov=vcovHC)
summary(modelis_po_aic)
# Chunk 11
datafr=data.frame(summary(modelis_po_aic)[c(4,8)] %>%  lapply(round,2))
colnames(datafr)=c("koeficientai","standartinis nuokrypis","koeficientu t reikšmes","p reiksme", "R kvadratas")
datafr[2:nrow(datafr),"R kvadratas"]="-"
kable(datafr)
# Chunk 12
names2=c("SP350","SP500","kk","dll","nedarbas","infliacija","mhope","phope","pramhope","shope","ta","ul","vhope","vp","mp","palukanos","gkl","ip","kursas")
for (i in 3:length(data3[1,])){
ccfvalues <- ccf(data3$OMX,data3[,i]) #aiskinames laga
print(names2[i-2])
print(ccfvalues)
}
# Chunk 13
modelis2 = lm(OMX ~ lag(SP350,0) + lag(kk,1) + lag(dll,1) + lag(nedarbas,5) + lag(mhope,3) + lag(phope,12) + lag(pramhope,3) + lag(shope,1) + lag(ul,10) + lag(vhope,4) + lag(vp,1) + lag(mp,1) + lag(gkl,19) + lag(ip,4) + lag(kursas,2) , data=data3)
modelis_po_aic <- lm(formula = OMX ~ lag(SP350, 1) + lag(nedarbas, 5) + lag(infliacija, 4) +
lag(mhope, 3) + lag(phope, 12) + lag(pramhope, 3) + lag(ul,10) + lag(vhope, 4) + lag(mp, 1) + lag(gkl, 19) + lag(ip,4) + lag(kursas, 2), data = data3)
# Chunk 14
ccfvalues <- ccf(data3$OMX,data3$kursas)
ccfvalues
modelis = lm(OMX ~ lag(SP350,0) + lag(kk,1) + lag(dll,1) + nedarbas + lag(mhope,3) + lag(phope,12) + lag(pramhope,3) + lag(shope,4) + lag(ul,10) + lag(vhope,4) + lag(vp,0) + lag(mp,1) + lag(gkl,9) + lag(ip,0) + lag(ip,1) + lag(ip,4) + lag(kursas,0) + lag(kursas,2) , data=data3)
boo<-stepAIC((modelis))
modelis_po_aic <- lm(formula = OMX ~ lag(SP350, 0) + lag(mhope, 3) + lag(phope, 12) + lag(pramhope, 3) + lag(ul, 10) + lag(gkl, 9) + lag(ip, 1)+ lag(kursas,2) , data = data3)
coeftest(modelis_po_aic, vcov=vcovHC)
summary(modelis_po_aic)
# Chunk 15
res<-bptest(modelis_po_aic)
# Chunk 16
ncvTest(modelis_po_aic)
# Kadangi p-value > 0.05, tai H0 hipotezė priimama - duomenys homoskedastiški.
spreadLevelPlot(modelis_po_aic)
vif(modelis_po_aic)
# Chunk 17
durbinWatsonTest(modelis_po_aic)
# p-value > 0.05 - liekanos nėra autokoreliuotos.
Box.test(modelis_po_aic$res, fitdf=0, type="Lj")
#p-value >0.05, vadinasi H0 neatmetama. Galima teigti, kad liekanos yra baltasis triukšmas.
# Chunk 18
shapiro.test(modelis_po_aic$residuals)
# p-value > 0.05 - liekanos yra normalios
names2=c("SP350","SP500","kk","dll","nedarbas","infliacija","mhope","phope","pramhope","shope","ta","ul","vhope","vp","mp","palukanos","gkl","ip","kursas")
for (i in 3:length(data3[1,])){
ccfvalues <- ccf(data3$ip,data3[,i]) #aiskinames laga
print(names2[i-2])
print(ccfvalues)
}
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) + lag(pramhope,8) + lag(shope,6) + lag(ul,4) + lag(vhope,5) + lag(vhope,9) + lag(vp,6) + lag(mp,0) + lag(gkl,9) + lag(kursas,0) , na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) + lag(pramhope,8) + lag(shope,6) + lag(ul,4)  + lag(vhope,9) + lag(vp,6) + lag(mp,0) + lag(gkl,9) + lag(kursas,0) , na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) + lag(pramhope,8) + lag(shope,6) + lag(ul,4) + lag(vhope,5)  + lag(vp,6) + lag(mp,0) + lag(gkl,9) + lag(kursas,0) , na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
mod_ip = lm( ip ~ lag(SP350,8), na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) , na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) , na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) + lag(pramhope,8), na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) + lag(pramhope,8) + lag(shope,6) + lag(ul,4), na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) + lag(pramhope,8) + lag(shope,6) + lag(ul,4) + lag(vhope,5) + lag(vhope,9) , na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) + lag(pramhope,8) + lag(shope,6) + lag(ul,4) + lag(vhope,5) , na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) + lag(pramhope,8) + lag(shope,6) + lag(ul,4) + lag(vhope,5) + lag(vp,6) + lag(mp,0) + lag(gkl,9) + lag(kursas,0) + lag(kursas,15), na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) + lag(pramhope,8) + lag(shope,6) + lag(ul,4) + lag(vhope,5) + lag(vp,6) , na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) + lag(pramhope,8) + lag(shope,6) + lag(ul,4) + lag(vhope,5) + lag(vp,6) + lag(mp,0)  + lag(kursas,0) + lag(kursas,15), na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) + lag(pramhope,8) + lag(shope,6) + lag(ul,4) + lag(vhope,5) + lag(vp,6) + lag(mp,0) + lag(gkl,9) , na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) + lag(pramhope,8) + lag(shope,6) + lag(ul,4) + lag(vhope,5) + lag(vp,6) + lag(mp,0) , na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) + lag(pramhope,8) + lag(shope,6) + lag(ul,4) + lag(vhope,5) + lag(vp,6) + lag(mp,0) + lag(gkl,9) , na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) + lag(pramhope,8) + lag(shope,6) + lag(ul,4) + lag(vhope,5) + lag(vp,6) + lag(mp,0)  + lag(kursas,15), na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) + lag(pramhope,8) + lag(shope,6) + lag(ul,4) + lag(vhope,5) + lag(vp,6) + lag(mp,0) + lag(gkl,9) + lag(kursas,0) , na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) + lag(pramhope,8) + lag(shope,6) + lag(ul,4) + lag(vhope,5) + lag(vp,6) + lag(mp,0)  + lag(kursas,0) , na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) + lag(pramhope,8) + lag(shope,6) + lag(ul,4) + lag(vhope,5) + lag(vhope,9) + lag(vp,6) + lag(mp,0)  + lag(kursas,0) + lag(kursas,15), na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) + lag(pramhope,8) + lag(shope,6) + lag(ul,4) + lag(vhope,5) + lag(vhope,9) + lag(vp,6) + lag(mp,0)  + lag(kursas,0), na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
for (i in 3:length(data3[1,])){
ccfvalues <- ccf(data3$ip,data3[,i]) #aiskinames laga
print(names2[i-2])
print(ccfvalues)
}
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) + lag(pramhope,8) + lag(shope,6) + lag(ul,4) + lag(vhope,5) + lag(vhope,9) + lag(vp,6) + lag(mp,0) + lag(gkl,0) + lag(kursas,0) + lag(kursas,15), na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) + lag(pramhope,8) + lag(shope,6) + lag(ul,4) + lag(vhope,5) + lag(vhope,9) + lag(vp,6) + lag(mp,0) + lag(gkl,0) + lag(kursas,0) + lag(kursas,15), na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) + lag(pramhope,8) + lag(shope,6) + lag(ul,4) + lag + lag(vp,6) + lag(mp,0) + lag(gkl,0) + lag(kursas,0), na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
View(data3)
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) + lag(pramhope,8) + lag(shope,6) + lag(ul,4) + lag(vhope,5) + lag(vhope,9) + lag(vp,6) + lag(mp,0)  + lag(kursas,0) + lag(kursas,15), na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
for (i in 3:length(data3[1,])){
ccfvalues <- ccf(data3$ip,data3[,i]) #aiskinames laga
print(names2[i-2])
print(ccfvalues)
}
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) + lag(pramhope,8) + lag(shope,6) + lag(ul,4) + lag(vhope,5) + lag(vp,6) + lag(mp,0) + lag(gkl,9) + lag(kursas,0), na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
mod_ip = lm( ip ~ lag(SP350,8)+ lag(kk,0) + lag(dll,5) + lag(nedarbas,1) + lag(mhope,4) + lag(phope,8) + lag(pramhope,8) + lag(shope,6) + lag(ul,4) + lag(vhope,5) + lag(vp,6) + lag(mp,0) + lag(gkl,0) + lag(kursas,0), na.action=na.omit, data=data3)
# ccf: kk - 0.750;
stepAIC(mod_ip)
mod_po_aic_ip = lm(ip ~ lag(SP350, 8) + lag(kk, 0) + lag(phope, 8) + lag(shope, 6) + lag(ul, 4) + lag(vp, 6) + lag(mp, 0) + lag(gkl, 0), data=data3)
ncvTest(mod_po_aic_ip)
# Kadangi p-value > 0.05, tai H0 hipotezė priimama - duomenys homoskedastiški.
coeftest(mod_po_aic_ip, vcov=vcovHC)
summary(mod_po_aic_ip)
modelis_po_aic <- lm(formula = OMX ~ lag(SP350, 0) + lag(mhope, 3) + lag(phope, 12) + lag(pramhope, 3) + lag(ul, 10) + lag(gkl, 9) + lag(ip, 1)+ lag(kursas,2)
, data = data3)
ncvTest(modelis_po_aic)
# Kadangi p-value > 0.05, tai H0 hipotezė priimama - duomenys homoskedastiški.
coeftest(modelis_po_aic, vcov=vcovHC)
summary(modelis_po_aic)
modelis_po_aic <- lm(formula = OMX ~ lag(SP350, 0) + lag(mhope, 3) + lag(phope, 12) + lag(pramhope, 3) + lag(ul, 10) + lag(gkl, 9) + lag(ip, 1)+ lag(kursas,2)
+
lag(kk, 1) + lag(shope, 7) + lag(vp, 7) + lag(mp, 1) # +1 lago, nes ip lag(1)
, data = data3)
ncvTest(modelis_po_aic)
# Kadangi p-value > 0.05, tai H0 hipotezė priimama - duomenys homoskedastiški.
coeftest(modelis_po_aic, vcov=vcovHC)
summary(modelis_po_aic)
mod_ip = lm( kursas ~ lag(SP350,0)+ lag(kk,12) + lag(dll,4) + lag(nedarbas,8) + lag(mhope,8) + lag(phope,2) + lag(pramhope,1) + lag(shope,11) + lag(ul,4) + lag(vhope,5) + lag(vp,0) + lag(mp,0) + lag(gkl,12) + lag(ip,2), data=data3)
# ccf: SP350 - 0.597;
stepAIC(mod_ip)
mod_po_aic_ip = lm(kursas ~ lag(SP350, 0) + lag(kk, 12) + lag(nedarbas, 8) + lag(mhope, 8) + lag(shope, 11) + lag(ul, 4) + lag(ip, 2), data=data3)
ncvTest(mod_po_aic_ip)
# Kadangi p-value > 0.05, tai H0 hipotezė priimama - duomenys homoskedastiški.
coeftest(mod_po_aic_ip, vcov=vcovHC)
summary(mod_po_aic_ip)
# PAGR MOD PLIUS PAPILDOMI KINTAMIEJI:
modelis_po_aic <- lm(formula = OMX ~ lag(SP350, 0) + lag(mhope, 3) + lag(phope, 12) + lag(pramhope, 3) + lag(ul, 10) + lag(gkl, 9) + lag(ip, 1)+ lag(kursas,2)
modelis_po_aic <- lm(formula = OMX ~ lag(SP350, 0) + lag(mhope, 3) + lag(phope, 12) + lag(pramhope, 3) + lag(ul, 10) + lag(gkl, 9) + lag(ip, 1)+ lag(kursas,2)
modelis_po_aic <- lm(formula = OMX ~ lag(SP350, 0) + lag(mhope, 3) + lag(phope, 12) + lag(pramhope, 3) + lag(ul, 10) + lag(gkl, 9) + lag(ip, 1)+ lag(kursas,2)
, data = data3)
ncvTest(modelis_po_aic)
# Kadangi p-value > 0.05, tai H0 hipotezė priimama - duomenys homoskedastiški.
coeftest(modelis_po_aic, vcov=vcovHC)
summary(modelis_po_aic)
modelis_po_aic <- lm(formula = OMX ~ lag(SP350, 0) + lag(mhope, 3) + lag(phope, 12) + lag(pramhope, 3) + lag(ul, 10) + lag(gkl, 9) + lag(ip, 1)+ lag(kursas,2)
+
lag(kk, 14) + lag(nedarbas, 10) + lag(shope, 13) # +2 lago, nes kursas lag(2)
, data = data3)
ncvTest(modelis_po_aic)
# Kadangi p-value > 0.05, tai H0 hipotezė priimama - duomenys homoskedastiški.
coeftest(modelis_po_aic, vcov=vcovHC)
summary(modelis_po_aic)
